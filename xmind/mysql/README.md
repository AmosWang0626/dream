# MySQL

## MySQL存储引擎

> MyISAM、InnoDB、Memory

#### MyISAM

不支持事务，不支持外键约束，索引文件和数据文件分开。内存中可以缓存更多的索引，对查询性能会更好，适用于那种少插入，多查询的场景。

经典案例：大数据场景下的报表系统。网站埋点日志、业务系统通过MySQL binlog同步业务数据，批量写入Hadoop后，在 T+1 进行离线批处理计算，
数据计算完，导入MySQL中，后边报表系统就可以直接从MySQL中查询已经计算好的数据，渲染成各种图，供他人使用。

但是在数据量非常多的情况下，几千万、几十亿数据时，MySQL是扛不住这么多数据的，一般建议单表500万以内数据量。

所以后来采用可配置化BI系统 + kylin + elastic search，支持大规模数据的复杂报表。

#### InnoDB

支持事务，强制要求主键，默认根据主键建立聚簇索引，支持外键约束。高并发（读写分离）、大数据量（分库分表）、高可用（主备切换）等相关成熟的数据库架构。

## MySQL索引相关

### 索引数据结构

> B树，B+树

##### B树

- 平衡的多路查找树，所有叶子结点都位于同一层。
- 一个5阶B树，每个结点最多有4个关键字。
- 每个结点都能存放数据或数据地址。

##### B+树

- B树的升级版，只有叶子结点才保存数据，所以每次查找次数都相同，更稳定。
- 另外，所有的叶子节点数据构成了一个有序链表，范围查找时性能更高。
- 全节点遍历时，只需要遍历所有的叶子节点即可，遍历速度更快。

#### MyISAM引擎中的索引实现（B+树）

MyISAM数据文件和索引文件是分开的，所以索引文件里的data都是指向数据文件中的一行。

#### InnoDB引擎中的索引实现（B+树）

- 聚簇索引
  > 强制要求主键，默认根据主键建立一个聚簇索引。数据文件本身就存在于根据主键建立的聚簇索引中。
  >
  > 如果没有主键，MySQL会自动找一个唯一列、或者隐式定义一个主键，以此来创建聚簇索引。

- 非聚簇索引
    - 如果查询的列，索引中完全包含，也就是覆盖索引，直接从索引中返回数据即可。
    - 如果查询的列，索引中不完全包含，那就会回表查询，根据索引中指向的地址，去聚簇索引中获取数据。

所以，在 InnoDB引擎里边，按照主键ID查询数据是很快的。

#### InnoDB引擎两个建议

1. 不推荐使用 UUID 作为主键
2. 推荐使用 自增ID 作为主键

原因如下：

- UUID 作为主键，键值32位字符串，多消耗磁盘空间，会使索引文件变大。
- 自增ID 是有序的，数据插入时，磁盘的顺序读写性能更高，也天然适合范围查找。
- UUID 生成的字符串是无序的，插入时，频繁移动磁盘块，自然性能就会低一些。

## 索引使用规则

1. 全列匹配（联合索引，作为条件时要是有序的）
2. 最左原则（如果没法全列匹配，要遵守最左原则，尽可能使最左的索引有较好区分度）
3. 前缀匹配（like "xxx%"，%不能放前边"%xxx%"）
4. 范围列匹配（符合最左原则才可以范围匹配，同时范围之后的无法使用索引）
5. 函数不能使用索引

索引缺点，注意事项

- 插入性能会降低
- 尽量少创建索引，2~3个
- 索引区分度要高（id【推荐】、status(0, 1)【区分度太低】）

## 主键数据类型选型

推荐使用自增ID，那么如果自增ID用完了怎么办？

- int
    - 带符号 -21,4748,3648 ~ 21,4748,3647
    - 无符号 0 ~ 42,9496,7295（约42亿）

- bigint
    - 带符号 -922,3372,0368,5477,5808 ~ 922,3372,0368,5477,5807
    - 无符号 0 ~ 1844,6744,0737,0955,1615

1. 默认是int类型，自增ID最大值 4294967295，可以改为bigint类型
    - 怎么修改，直接Alter修改肯定需要停服，大概率是可以停服的
    - 如果不可以停服，主从切换，分别修改
2. 另外，单表数据量过亿，系统肯定早就应该重构了
    - 分库分表概括一下
    - 分库分表主键ID可采用雪花算法，或者其他分布式ID解决方案
