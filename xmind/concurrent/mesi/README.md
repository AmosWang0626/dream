# MESI协议（缓存一致性）

- S：Share 共享的
- I：Invalid 无效的
- E：Exclusive 独占的
- M：Modified 已修改

Cache Entry（tag, cache line, flag）

1. 处理器0读取变量，高速缓存里没有，就向总线发送消息，总线从主内存或者其他处理器的高速缓存中读取到该变量，
返回给处理器0，处理器0将变量放到 Cache Entry 里边，此时，flag = S
2. 同时处理器1也读取了这个变量，同样 flag = S
3. 处理器0要修改了该变量，就向总线发送invalidate消息，尝试让其他处理器将对应Cache Entry全部变成 I
4. 处理器1嗅探到invalidate消息，将自己的Cache Entry设置为 I，并返回invalidate ack消息到总线
5. 处理器0嗅探到所有处理器都返回invalidate ack消息了，就将自己的Cache Entry先设置为 E，独占这条消息
6. 如果有别的同时来修改，并发送invalidate，这个处理器0是不会返回invalidate ack消息的
7. 接着，处理器0开始修改这条数据，并设置 flag = M，也有可能把数据强制写会主内存，具体看硬件实现

## 性能问题

上述着一系列操作，是同步阻塞的，例如线程0要等待其他线程都返回invalidate ack，这边才能继续进行独占写操作；
其他处理器收到invalidate消息之后，需要修改自己的Cache Entry的flag，之后再ack处理器0；

然后，这里引入了写缓冲器和无效队列。

1. 写缓冲器。处理器写数据时，直接把数据写入缓冲器，同时发送invalidate消息，然后就认为写入完成了，不会阻塞在这里。
   接着，处理器如果收到所有处理器ack消息之后，再把写缓冲器中的结果拿出来，通过设置E加独占锁，同时修改数据，设置为M
2. 同时，查询数据时，会先从写缓冲器中查询，然后才会从高速缓存里查，这就是存储转发
3. 无效队列。其他处理器接收到invalidate消息之后，不需要立马过期掉本地缓存，直接将消息放入无效队列，同时返回ack给
   那个写处理器，之后，从无效队列里取出消息，过期本地缓存即可

