# MESI协议（缓存一致性）

- S：Share 共享的
- I：Invalid 无效的
- E：Exclusive 独占的
- M：Modified 已修改

Cache Entry（tag, cache line, flag）

1. 处理器0读取变量，高速缓存里没有，就向总线发送消息，总线从主内存或者其他处理器的高速缓存中读取到该变量，
返回给处理器0，处理器0将变量放到 Cache Entry 里边，此时，flag = S
2. 同时处理器1也读取了这个变量，同样 flag = S
3. 处理器0要修改了该变量，就向总线发送invalidate消息，尝试让其他处理器将对应Cache Entry全部变成 I
4. 处理器1嗅探到invalidate消息，将自己的Cache Entry设置为 I，并返回invalidate ack消息到总线
5. 处理器0嗅探到所有处理器都返回invalidate ack消息了，就将自己的Cache Entry先设置为 E，独占这条消息
6. 如果有别的同时来修改，并发送invalidate，这个处理器0是不会返回invalidate ack消息的
7. 接着，处理器0开始修改这条数据，并设置 flag = M，也有可能把数据强制写会主内存，具体看硬件实现

## 性能问题

上述着一系列操作，是同步阻塞的，例如线程0要等待其他线程都返回invalidate ack，这边才能继续进行独占写操作；
其他处理器收到invalidate消息之后，需要修改自己的Cache Entry的flag，之后再ack处理器0；

然后，这里引入了写缓冲器和无效队列。

1. 写缓冲器。处理器写数据时，直接把数据写入缓冲器，同时发送invalidate消息，然后就认为写入完成了，不会阻塞在这里。
   接着，处理器如果收到所有处理器ack消息之后，再把写缓冲器中的结果拿出来，通过设置E加独占锁，同时修改数据，设置为M
2. 同时，查询数据时，会先从写缓冲器中查询，然后才会从高速缓存里查，这就是存储转发
3. 无效队列。其他处理器接收到invalidate消息之后，不需要立马过期掉本地缓存，直接将消息放入无效队列，同时返回ack给
   那个写处理器，之后，从无效队列里取出消息，过期本地缓存即可

## 为什么MESI会引发有序性和可见性问题？

正是因为引入了写缓冲器和无效队列

- 写数据的时候，刚写到了写缓冲器，其他线程来执行读操作，从高速缓存里边读，读到的是旧值；
- 写数据的时候，该数据已经在无效队列里边了，但还没来得及写入高速缓存，其他线程来执行读操作，从高速缓存里边读，读到的是无效的值。

#### （1）StoreLoad重排序

```java
// 代码示例

int a = 0;
int c = 1;

// Thread 1:

a = 1; // Store操作，此时，写操作会先写到写缓冲器里边
int b = c; // Load操作，直接执行完成了

// 结果：外部看来，是Load成功了，Store还未执行完成！
```

#### （2）StoreStore重排序

```java
// 假设，这个写操作，a 在高速缓存中的状态是 S，共享的
a = loadResource();
// 假设，这个写操作，b 在高速缓存中的状态是 M，当前线程已经加过锁的，没有其他线程使用这个变量，可以直接写到高速缓存
b = 0;

// 结果：外部看来，第二个写操作先发生，第一个写操作还未发生（未执行完成）
```

## 内存屏障在硬件层面的实现原理以及如何解决各种问题

本质上还是Store + Load内存屏障

- 如果加了Store屏障，强制要求写操作必须阻塞等待到其他处理器返回invalidate ack之后，对数据加锁，然后修改数据到高速缓存（或主内存）中，强制执行flush操作，不能只停留在写缓冲器中。
- 如果加了Load屏障，在从高速缓存中读取数据时，如果发现无效队列里有invalidate消息，此时会立马强制根据invalidate消息把本地高速缓存中的数据flag改为I，然后强制从其他处理器高速缓存中加载最新的值，也即refresh操作。

#### StoreStore屏障解决重排序

```java
// cache entry flag is S
a = loadResource();

// StoreStore屏障

// cache entry flag is M
b = 0;
```

解决办法：第一个写操作由于变量状态是Share的，所以会先写到写缓冲器中；第二个写操作，即使变量状态是Invalid的，它也必须写到写缓冲器中，保证有序性。

#### StoreLoad屏障解决可见性和有序性

```java
a = 1; // Store操作，此时，写操作会先写到写缓冲器里边
        
int b = c; // Load操作，直接执行完成了
```

解决办法：第一步写操作，强制要求必须直接写到高速缓存，不能停留在写缓冲器里，清空写缓冲器里的这条数据。

